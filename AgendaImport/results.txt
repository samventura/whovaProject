10:00 AM
10:00 AM
10:00 AM
[{'date': '06/16/2018', 'time_start': '10:00 AM', 'time_end': '10:40 AM', 'session_type': 'Session', 'title': 'Lightning session I', 'location': 'Room Coral 1', 'description': '<p><span style="color: rgb(34, 34, 34); font-family: arial, sans-serif; font-size: 13px; line-height: normal;">The lightning session is an incredibly valuable addition to the conference. Every attendee sees every research paper once, which benefits disproportionately to the time taken to see each paper. It is a quick and fun introduction to all research papers and helps attendees make a decision regarding which session they want to attend.</span></p><p><span style="color: rgb(34, 34, 34); font-family: arial, sans-serif; font-size: 13px; line-height: normal;">The lightning session is an incredibly valuable addition to the conference. Everyone sees every paper once has benefit disproportionate to the time taken. It is a quick and fun introduction to all the papers and help attendees to make decisions on which sessions they wanted to attend by the end of it.</span></p>', 'speakers': 'John Regehr', 'session_num': 6, 'subsess_num': 1}, {'date': '06/17/2018', 'time_start': '10:00 AM', 'time_end': '11:40 AM', 'session_type': 'Session', 'title': 'Session 4A: Virtualization:', 'location': 'Room 201', 'description': '<p>Paravirtualization is an important I/O virtualization technology since it uniquely provides all of the following benefits: the ability to share the device between multiple VMs, support for legacy devices without virtualization hardware, and high performance. However, existing paravirtualization solutions have one main limitation: they only support one I/O device class, and would require significant engineering effort to support new device classes and features.</p>', 'speakers': 'Carl A. Waldspurger', 'session_num': 22, 'subsess_num': 1}, {'date': '06/17/2018', 'time_start': '10:00 AM', 'time_end': '10:25 AM', 'session_type': 'Sub', 'title': 'I/O Paravirtualization at the Device File Boundary ', 'location': 'Coral 1', 'description': 'Paravirtualization is an important I/O virtualization technology since it uniquely provides all of the following benefits: the ability to share the device between multiple VMs, support for legacy devices without virtualization hardware, and high performance. However, existing paravirtualization solutions have one main limitation: they only support one I/O device class, and would require significant engineering effort to support new device classes and features. In this paper, we present Paradice, a solution that vastly simplifies I/O paravirtualization by using a common paravirtualization boundary for various I/O device classes: Unix device files. Using this boundary, the paravirtual drivers simply act as a class-agnostic indirection layer between the application and the actual device driver.\n\nWe address two fundamental challenges: supporting cross-VM driver memory operations without changes to applications or device drivers and providing fault and device data isolation between guest VMs despite device driver bugs. We implement Paradice for x86, the Xen hypervisor, and the Linux and FreeBSD OSes. Our implementation paravirtualizes various GPUs, input devices, cameras, an audio device, and an Ethernet card for the netmap framework with ~7700 LoC, of which only ~900 are device class-specific. Our measurements show that Paradice achieves performance close to native for different devices and applications including netmap, 3D HD games, and OpenCL applications.', 'speakers': 'Ardalan Amiri Sani; Kevin Boos; Shaopu Qin; Lin Zhong', 'session_num': 22, 'subsess_num': 2}, {'date': '06/17/2018', 'time_start': '10:15 AM', 'time_end': '11:40 AM', 'session_type': 'Sub', 'title': 'KVM/ARM: The Design and Implementation of the Linux ARM Hypervisor ', 'location': 'Coral 2', 'description': 'As ARM CPUs become increasingly common in mobile devices and servers, there is a growing demand for providing the benefits of virtualization for ARM-based devices. We present our experiences building the Linux ARM hypervisor, KVM/ARM, the first full system ARM virtualization solution that can run unmodified guest operating systems on ARM multicore hardware. KVM/ARM introduces split-mode virtualization, allowing a hypervisor to split its execution across CPU modes and be integrated into the Linux kernel. This allows KVM/ARM to leverage existing Linux hardware support and functionality to simplify hypervisor development and maintainability while utilizing recent ARM hardware virtualization extensions to run virtual machines with comparable performance to native execution. KVM/ARM has been successfully merged into the mainline Linux kernel, ensuring that it will gain wide adoption as the virtualization platform of choice for ARM. We provide the first measurements on real hardware of a complete hypervisor using ARM hardware virtualization support. Our results demonstrate that KVM/ARM has modest virtualization performance and power costs, and can achieve lower performance and power costs compared to x86-based Linux virtualization on multicore hardware.', 'speakers': 'Christoffer Dall; Jason Nieh', 'session_num': 22, 'subsess_num': 3}, {'date': '06/17/2018', 'time_start': '10:25 AM', 'time_end': '10:50 AM', 'session_type': 'Sub', 'title': 'VSwapper: A Memory Swapper for Virtualized Environments ', 'location': 'Coral 3', 'description': 'The number of guest virtual machines that can be consolidated on one physical host is typically limited by the memory size, motivating memory overcommitment. Guests are given a choice to either install a "balloon" driver to coordinate the overcommitment activity, or to experience degraded performance due to uncooperative swapping. Ballooning, however, is not a complete solution, as hosts must still fall back on uncooperative swapping in various circumstances. Additionally, ballooning takes time to accommodate change, and so guests might experience degraded performance under changing conditions.\n\nOur goal is to improve the performance of hosts when they fall back on uncooperative swapping and/or operate under changing load conditions. We carefully isolate and characterize the causes for the associated poor performance, which include various types of superfluous swap operations, decayed swap file sequentiality, and ineffective prefetch decisions upon page faults. We address these problems by implementing VSwapper, a guest-agnostic memory swapper for virtual environments that allows efficient, uncooperative overcommitment. With inactive ballooning, VSwapper yields up to an order of magnitude performance improvement. Combined with ballooning, VSwapper can achieve up to double the performance under changing load conditions.', 'speakers': 'Nadav Amit; Dan Tsafrir; Assaf Schuster', 'session_num': 22, 'subsess_num': 4}, {'date': '06/17/2018', 'time_start': '10:50 AM', 'time_end': '11:15 AM', 'session_type': 'Sub', 'title': 'Cider: Native Execution of iOS Apps on Android ', 'location': 'Coral 4', 'description': 'We present Cider, an operating system compatibility architecture that can run applications built for different mobile ecosystems, iOS or Android, together on the same smartphone or tablet. Cider enhances the domestic operating system, Android, of a device with kernel-managed, per-thread personas to mimic the application binary interface of a foreign operating system, iOS, enabling it to run unmodified foreign binaries. This is accomplished using a novel combination of binary compatibility techniques including two new mechanisms: compile-time code adaptation, and diplomatic functions. Compile-time code adaptation enables existing unmodified foreign source code to be reused in the domestic kernel, reducing implementation effort required to support multiple binary interfaces for executing domestic and foreign applications. Diplomatic functions leverage per-thread personas, and allow foreign applications to use domestic libraries to access proprietary software and hardware interfaces. We have built a Cider prototype, and demonstrate that it imposes modest performance overhead and runs unmodified iOS and Android applications together on a Google Nexus tablet running the latest version of Android.', 'speakers': "Jeremy Andrus; Alexander Van't Hof; Naser AlDuaij; Christoffer Dall; Nicolas Viennot; Jason Nieh", 'session_num': 22, 'subsess_num': 5}, {'date': '06/17/2018', 'time_start': '10:00 AM', 'time_end': '11:40 AM', 'session_type': 'Session', 'title': 'Session 4B: Transactional memory and consistency: ', 'location': 'Room 300', 'description': '<p><span style="color: #000000; font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 11px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px; display: inline !important; float: none; background-color: #ffffff;">Transactional memory represents an attractive conceptual model for programming concurrent applications. Unfortunately, high transaction abort rates can cause significant performance degradation. Conventional transactional memory realizations not only pessimistically abort transactions on every read-write conflict but also because of false sharing, cache evictions, TLB misses, page faults and interrupts.</span></p>', 'speakers': 'Sandhya Dwarkadas', 'session_num': 23, 'subsess_num': 1}, {'date': '06/17/2018', 'time_start': '10:00 AM', 'time_end': '10:25 AM', 'session_type': 'Sub', 'title': 'SI-TM: Reducing Transactional Memory Abort Rates through Snapshot Isolation', 'location': 'Coral 5', 'description': 'Transactional memory represents an attractive conceptual model for programming concurrent applications. Unfortunately, high transaction abort rates can cause significant performance degradation. Conventional transactional memory realizations not only pessimistically abort transactions on every read-write conflict but also because of false sharing, cache evictions, TLB misses, page faults and interrupts. Consequently, the use of transactions needs to be restricted to a very small number of operations to achieve predictable performance, thereby, limiting its benefit to programming simplification. In this paper, we investigate snapshot isolation transactional memory in which transactions operate on memory snapshots that always guarantee consistent reads. By exploiting snapshots, an established database model of transactions, transactions can ignore read-write conflicts and only need to abort on write-write conflicts. Our implementation utilizes a memory controller that supports multiversion memory, to efficiently support snapshotting in hardware.We show that snapshot isolation can reduce the number of aborts in some cases by three orders of magnitude and improve performance by up to 20x.', 'speakers': 'Heiner Litz; David Cheriton; Omid Azizi; Amin Firoozshahian; John P. Stevenson', 'session_num': 23, 'subsess_num': 2}, {'date': '06/17/2018', 'time_start': '10:25 AM', 'time_end': '10:50 AM', 'session_type': 'Sub', 'title': 'Transactionalizing Legacy Code: An Experience Report Using GCC and Memcached ', 'location': 'Coral 4', 'description': 'The addition of transactional memory (TM) support to existing languages provides the opportunity to create new soft- ware from scratch using transactions, and also to simplify or extend legacy code by replacing existing synchronization with language-level transactions. In this paper, we describe our experiences transactionalizing the memcached application through the use of the GCC implementation of the Draft C++ TM Specification. We present experiences and recommendations that we hope will guide the effort to integrate TM into languages, and that may also contribute to the growing collective knowledge about how programmers can begin to exploit TM in existing production-quality software.', 'speakers': 'Michael Spear; Trilok Vyas; Wenjia Ruan; Yujie Liu', 'session_num': 23, 'subsess_num': 3}, {'date': '06/17/2018', 'time_start': '10:50 AM', 'time_end': '11:15 AM', 'session_type': 'Sub', 'title': 'Fence-Free Work Stealing on Bounded TSO Processors ', 'location': 'Coral 3', 'description': 'Work stealing is the method of choice for load balancing in task parallel programming languages and frameworks. Yet despite considerable effort invested in optimizing work stealing task queues, existing algorithms issue a costly memory fence when removing a task, and these fences are believed to be necessary for correctness.\n\nThis paper refutes this belief, demonstrating work stealing algorithms in which a worker does not issue a memory fence for microarchitectures with a bounded total store ordering (TSO) memory model. Bounded TSO is a novel restriction of TSO~-- capturing mainstream x86 and SPARC TSO processors -- that bounds the number of stores a load can be reordered with.\n\nOur algorithms eliminate the memory fence penalty, improving the running time of a suite of parallel benchmarks on modern x86 multicore processors by 7%-11% on average (and up to 23%), compared to the Cilk and Chase-Lev work stealing queues.', 'speakers': 'Adam Morrison; Yehuda Afek', 'session_num': 23, 'subsess_num': 4}, {'date': '06/17/2018', 'time_start': '11:15 AM', 'time_end': '11:40 AM', 'session_type': 'Sub', 'title': 'Adapting Data-Race-Free Memory Consistency to Heterogeneous Systems', 'location': 'Coral 2', 'description': 'Commodity heterogeneous systems (e.g., integrated CPUs and GPUs), now support a unified, shared memory address space for all components. Because the latency of global communication in a heterogeneous system can be prohibi-tively high, heterogeneous systems (unlike homogeneous CPU systems) provide synchronization mechanisms that only guarantee ordering among a subset of threads, which we call a scope. Unfortunately, the consequences and se-mantics of these scoped operations are not yet well under-stood. Without a formal and approachable model to reason about the behavior of these operations, we risk an array of portability and performance issues.\n\nIn this paper, we embrace scoped synchronization with a new class of memory consistency models that add scoped synchronization to data-race-free models like those of C++ and Java. Called sequential consistency for heterogeneous-race-free (SC for HRF), the new models guarantee SC for programs with "sufficient" synchronization (no data races) of "sufficient" scope. We discuss two such models. The first, HRF-direct, works well for programs with highly regular parallelism. The second, HRF-indirect, builds on HRF-direct by allowing synchronization using different scopes in some cases involving transitive communication. We quanti-tatively show that HRF-indirect encourages forward-looking programs with irregular parallelism by showing up to a 10% performance increase in a task runtime for GPUs.', 'speakers': 'Derek Hower; Bradford M. Beckmann; Benedict R. Gaster; Blake A. Hechtman; Mark Hill; Steven K. Reinhardt; David Wood', 'session_num': 23, 'subsess_num': 5}, {'date': '06/18/2018', 'time_start': '10:00 AM', 'time_end': '10:30 AM', 'session_type': 'Session', 'title': 'Break', 'location': 'Coral Lounge', 'description': '', 'speakers': '', 'session_num': 33, 'subsess_num': 1}]
